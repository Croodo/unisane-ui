/**
 * Route handler code generation
 */
import type { RouteGenEntry } from '../../extraction/types.js';
import { ImportBuilder, toModuleImport } from './imports.js';
import {
  collectParamKeys,
  generateParamsType,
  generateValueAccessor,
  applyTransform,
  applyFallback,
} from './params.js';

export interface RenderOptions {
  /** Use @unisane/* package imports (true) or @/src/modules/* (false) */
  usePackages?: boolean;
  /** Gateway import path for httpHandler */
  gatewayPath?: string;
  /** Audit module import path */
  auditPath?: string;
  /** RBAC module import path */
  rbacPath?: string;
  /** Query DSL import path */
  queryDslPath?: string;
  /** Query parser import path */
  queryPath?: string;
  /** Env import path for fallback values */
  envPath?: string;
}

const DEFAULT_OPTIONS: Required<RenderOptions> = {
  usePackages: true,
  gatewayPath: '@unisane/gateway',
  auditPath: '@unisane/audit',
  rbacPath: '@unisane/gateway/rbac',
  queryDslPath: '@unisane/gateway/queryDsl',
  queryPath: '@unisane/gateway/query',
  envPath: '@/src/shared/env',
};

/**
 * Render a route handler for a single operation
 */
export async function renderRouteHandler(args: {
  opKey: string;
  method: string;
  cfg: RouteGenEntry;
  options?: RenderOptions;
}): Promise<string> {
  const { opKey, method, cfg, options = {} } = args;
  const opts = { ...DEFAULT_OPTIONS, ...options };

  const header = `/* AUTO-GENERATED by 'npm run routes:gen' â€” DO NOT EDIT */`;
  const hasBody = !!cfg.zodBody;
  const hasQuery = !!cfg.zodQuery;
  const handlerName = method.toUpperCase();
  const bodyAlias = hasBody ? `__BodySchema_${handlerName}` : '';
  const queryAlias = hasQuery ? `__QuerySchema_${handlerName}` : '';

  const imports = new ImportBuilder(opts.usePackages);

  // Add httpHandler import
  imports.add(opts.gatewayPath, cfg.raw ? 'makeHandlerRaw' : 'makeHandler');

  // Add service import
  const serviceImportPath = toModuleImport(cfg.importPath, opts.usePackages);
  const factoryImportPath = cfg.factory
    ? toModuleImport(cfg.factory.importPath, opts.usePackages)
    : null;
  const factoryClobbersService =
    factoryImportPath &&
    factoryImportPath === serviceImportPath &&
    cfg.factory?.name === cfg.fn;

  if (!factoryClobbersService) {
    imports.add(serviceImportPath, cfg.fn);
  }

  // Add extra imports
  if (cfg.extraImports && cfg.extraImports.length) {
    for (const e of cfg.extraImports) {
      imports.add(toModuleImport(e.importPath, opts.usePackages), e.names);
    }
  }

  // Add audit import if needed
  if (cfg.audit) {
    imports.add(opts.auditPath, 'appendAudit');
  }

  // Build guard configuration
  const guardBits: string[] = [];
  guardBits.push(`op: "${cfg.op ?? opKey}"`);
  if (cfg.allowUnauthed) guardBits.push('allowUnauthed: true');
  if (cfg.requireUser) guardBits.push('requireUser: true');
  if (cfg.requireTenantMatch) guardBits.push('requireTenantMatch: true');
  if (cfg.requireSuperAdmin) guardBits.push('requireSuperAdmin: true');

  // Add permission (as identifier, not string)
  if (cfg.perm) {
    guardBits.push(`perm: ${cfg.perm}`);
    if (cfg.perm.startsWith('PERM.')) {
      imports.add(opts.rbacPath, 'PERM');
    }
  }
  if (cfg.idempotent) guardBits.push('idempotent: true');

  const guard = `{ ${guardBits.join(', ')}${hasBody ? `, zod: ${bodyAlias}` : ''} }`;

  const beforeCall: string[] = [];
  let bodySchemaDecl: string | null = null;
  let querySchemaDecl: string | null = null;

  // Collect param keys for typed params
  const paramKeys = collectParamKeys(cfg);
  const paramsType = generateParamsType(paramKeys, !!cfg.audit);
  const needsTypedParams = paramKeys.length > 0 || cfg.audit;

  if (needsTypedParams) {
    beforeCall.push(`const __params = params as ${paramsType};`);
  }

  // Body handling
  let bodyRef = 'body';
  if (hasBody) {
    imports.add('zod', 'z');
    const ip = toModuleImport(cfg.zodBody!.importPath, opts.usePackages);
    const nm = cfg.zodBody!.name;
    const isIdent = /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(nm);
    if (isIdent) {
      imports.add(ip, `${nm} as ${bodyAlias}`);
    } else {
      imports.add(ip, nm);
      bodySchemaDecl = `const ${bodyAlias} = ${nm};`;
    }
    bodyRef = '__body';
    beforeCall.push(`const ${bodyRef}: z.output<typeof ${bodyAlias}> = body!;`);
  }

  // List handling
  const listKind = cfg.listKind;
  const filtersSchema = cfg.filtersSchema;
  const isAdminList = listKind === 'admin';
  // Support filter parsing for non-list endpoints (e.g., stats) that have filtersSchema
  const needsFilterParsing = !!filtersSchema && !isAdminList;

  if (isAdminList) {
    imports.add(opts.queryDslPath, 'parseListParams');
    if (filtersSchema) {
      imports.add(toModuleImport(filtersSchema.importPath, opts.usePackages), filtersSchema.name);
    }
  } else if (needsFilterParsing) {
    // For non-list endpoints with filters (e.g., stats), add filter schema import
    imports.add(toModuleImport(filtersSchema.importPath, opts.usePackages), filtersSchema.name);
  }

  // Query handling
  if (hasQuery) {
    const ip = toModuleImport(cfg.zodQuery!.importPath, opts.usePackages);
    const nm = cfg.zodQuery!.name;
    const isIdent = /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(nm);
    if (isIdent) {
      imports.add(ip, `${nm} as ${queryAlias}`);
    } else {
      imports.add(ip, nm);
      querySchemaDecl = `const ${queryAlias} = ${nm};`;
    }
  }

  // Check if callArgs reference 'query' but no zodQuery provided
  const needsQuery =
    Array.isArray(cfg.callArgs) &&
    cfg.callArgs.some((a) => a.from === 'query');

  if (isAdminList) {
    beforeCall.push(
      `const url = new URL(req.url);`,
      `const { limit, cursor, sort, filtersRaw } = parseListParams(url.searchParams, { defaultLimit: 50, maxLimit: 50 });`,
      `let filters: unknown;`,
      `if (filtersRaw) {`,
      `  try {`,
      `    filters = JSON.parse(filtersRaw);`,
      `  } catch {`,
      `    try {`,
      `      const decoded = Buffer.from(filtersRaw, 'base64url').toString('utf8');`,
      `      filters = JSON.parse(decoded);`,
      `    } catch {`,
      `      throw new Error('filters must be valid JSON or base64url JSON');`,
      `    }`,
      `  }`,
      `}`,
      `const filtersTyped = ${filtersSchema ? `${filtersSchema.name}.parse(filters ?? {})` : 'filters'};`,
      `const queryInput = { limit, ...(cursor ? { cursor } : {}), ...(sort ? { sort } : {}), ...(filtersTyped ? { filters: filtersTyped } : {}) };`,
      `const __query = ${hasQuery ? `${queryAlias}.parse(queryInput)` : 'queryInput'};`
    );
  } else if (needsFilterParsing && hasQuery) {
    // Non-list endpoint with filters (e.g., stats) - parse filters from query param
    beforeCall.push(
      `const url = new URL(req.url);`,
      `const filtersRaw = url.searchParams.get('filters');`,
      `let filters: unknown;`,
      `if (filtersRaw) {`,
      `  try {`,
      `    filters = JSON.parse(filtersRaw);`,
      `  } catch {`,
      `    try {`,
      `      const decoded = Buffer.from(filtersRaw, 'base64url').toString('utf8');`,
      `      filters = JSON.parse(decoded);`,
      `    } catch {`,
      `      throw new Error('filters must be valid JSON or base64url JSON');`,
      `    }`,
      `  }`,
      `}`,
      `const filtersTyped = ${filtersSchema!.name}.parse(filters ?? {});`,
      `const __query = { filters: filtersTyped };`
    );
  } else if (hasQuery) {
    imports.add(opts.queryPath, 'parseQuery as parseQueryZ');
    beforeCall.push(`const __query = parseQueryZ(req, ${queryAlias});`);
  } else if (needsQuery) {
    beforeCall.push(
      `const __query = Object.fromEntries(new URL(req.url).searchParams.entries());`
    );
  }

  // Build the service call
  let callBuilt = '';
  const isValidCallExpr = (v: unknown): v is string => {
    if (typeof v !== 'string') return false;
    const t = v.trim();
    if (!t.length) return false;
    if (t === 'undefined' || t === 'void 0' || t === 'null') return false;
    return true;
  };

  if (cfg.invoke && Array.isArray(cfg.callArgs) && cfg.callArgs.length) {
    const argDecls: string[] = [];
    const objProps: string[] = [];
    const posArgs: string[] = [];

    for (const arg of cfg.callArgs) {
      const varName = `__arg_${String(arg.name).replace(/[^a-zA-Z0-9_]/g, '_')}`;
      let src =
        arg.from === 'const'
          ? JSON.stringify(arg.value)
          : generateValueAccessor(arg, bodyRef, hasBody);

      src = applyFallback(src, arg.fallback, opts.envPath);
      src = applyTransform(src, arg.transform);

      argDecls.push(`const ${varName} = ${src};`);

      if (cfg.invoke === 'object') {
        const hasFallback = !!arg.fallback;
        if (arg.optional && !hasFallback) {
          objProps.push(`...(${varName} !== undefined ? { ${arg.name}: ${varName} } : {})`);
        } else {
          objProps.push(`${arg.name}: ${varName}`);
        }
      } else {
        posArgs.push(varName);
      }
    }

    beforeCall.push(...argDecls);

    // Capture audit "before" state BEFORE service call
    if (cfg.audit && cfg.audit.beforeExpr) {
      beforeCall.push(
        `const __auditBefore = await Promise.resolve(${cfg.audit.beforeExpr});`
      );
    }

    // Build the function call
    callBuilt =
      cfg.invoke === 'object'
        ? `${cfg.fn}({ ${objProps.join(', ')} } as unknown as Parameters<typeof ${cfg.fn}>[0])`
        : `${cfg.fn}(${posArgs.join(', ')})`;
    beforeCall.push(`const result = await (${callBuilt});`);
  } else if (
    cfg.factory &&
    typeof cfg.factory.importPath === 'string' &&
    typeof cfg.factory.name === 'string'
  ) {
    const facPath = toModuleImport(cfg.factory.importPath, opts.usePackages);
    const facName = cfg.factory.name;
    const alias = factoryClobbersService ? `${facName} as __factory` : facName;
    imports.add(facPath, alias);
    const passQuery = cfg.zodQuery ? ', query: __query' : '';
    const passBody = cfg.zodBody
      ? `, ...(body !== undefined ? { body } : {})`
      : '';
    const factoryIdent = factoryClobbersService ? '__factory' : facName;
    beforeCall.push(
      `const result = await (${factoryIdent}({ req, ctx, ...(params ? { params: params as Record<string, unknown> } : {})${passBody}${passQuery}, requestId } as Parameters<typeof ${factoryIdent}>[0]));`
    );
  } else if (isValidCallExpr(cfg.callExpr)) {
    beforeCall.push(`const result = await (${cfg.callExpr});`);
  }

  // Audit handling
  if (cfg.audit) {
    const ridExpr = cfg.audit.resourceIdExpr ?? 'null';
    const trimmedRid = ridExpr.trim();

    let rid: string;
    if (ridExpr === 'null') {
      rid = 'null';
    } else if (
      trimmedRid.startsWith('`') &&
      (ridExpr.includes('bodySafe.') || ridExpr.includes('body.'))
    ) {
      rid = ridExpr
        .replace(/bodySafe\./g, `${bodyRef}.`)
        .replace(/\bbody\./g, `${bodyRef}.`);
    } else if (
      trimmedRid.startsWith("'") ||
      trimmedRid.startsWith('"') ||
      trimmedRid.startsWith('`')
    ) {
      rid = ridExpr;
    } else if (trimmedRid.startsWith('params.')) {
      const key = trimmedRid.replace('params.', '');
      rid = `__params.${key} ?? null`;
    } else if (
      trimmedRid.startsWith('body.') ||
      trimmedRid.startsWith('bodySafe.')
    ) {
      const key = trimmedRid.replace(/^body(Safe)?\./, '');
      rid = hasBody ? `String(${bodyRef}.${key} ?? '') || null` : 'null';
    } else if (ridExpr.includes('bodySafe.') || ridExpr.includes('body.')) {
      const replaced = ridExpr
        .replace(/bodySafe\./g, `${bodyRef}.`)
        .replace(/\bbody\./g, `${bodyRef}.`);
      rid = `(${replaced} != null ? String(${replaced}) : null)`;
    } else {
      rid = `(${ridExpr} != null ? String(${ridExpr}) : null)`;
    }

    const afterExpr = cfg.audit.afterExpr;
    const beforeRef = cfg.audit.beforeExpr ? '__auditBefore' : 'undefined';

    const auditParts: string[] = [
      `tenantId: __params?.tenantId ?? ctx.tenantId ?? '-'`,
      `...(ctx.userId ? { actorId: ctx.userId } : {})`,
      `action: '${opKey}'`,
      `resourceType: '${cfg.audit.resourceType}'`,
      `resourceId: ${rid}`,
    ];

    if (beforeRef !== 'undefined') {
      auditParts.push(
        `...(${beforeRef} !== undefined ? { before: ${beforeRef} } : {})`
      );
    }

    if (afterExpr) {
      const trimmedAfter = afterExpr.trim();
      if (trimmedAfter.startsWith('{')) {
        auditParts.push(`after: ${afterExpr}`);
      } else {
        auditParts.push(
          `...(${afterExpr} !== undefined ? { after: ${afterExpr} } : {})`
        );
      }
    }

    auditParts.push(`requestId`, `ip`, `ua`);

    beforeCall.push(
      `const ip = req.headers.get('x-forwarded-for') ?? null;`,
      `const ua = req.headers.get('user-agent') ?? null;`,
      `await appendAudit({ ${auditParts.join(', ')} });`
    );
  }

  // Ensure we have a call
  const hasCallExpr = isValidCallExpr(cfg.callExpr);
  const hasCallArgs =
    !!cfg.invoke && Array.isArray(cfg.callArgs) && cfg.callArgs.length > 0;
  const hasFactory =
    !!cfg.factory &&
    typeof cfg.factory.importPath === 'string' &&
    typeof cfg.factory.name === 'string';

  if (!hasCallExpr && !hasCallArgs && !hasFactory) {
    if (cfg.fn && !cfg.invoke) {
      beforeCall.push(`const result = await (${cfg.fn}());`);
    } else {
      throw new Error(
        `[gen-routes] ${opKey}: no call defined. Provide one of: service.callExpr, service.callArgs+invoke, or service.factory`
      );
    }
  }

  // Build final imports
  const importLines = imports.build();
  const userCode = beforeCall.join('\n    ');

  // Generate handler
  if (cfg.raw) {
    const rawGuardBits = [...guardBits];
    if (hasBody) rawGuardBits.push(`zod: ${bodyAlias}`);
    const rawGuard = `({ ${rawGuardBits.join(', ')}${cfg.rateKeyExpr ? `, rateKey: ({ req, ctx, body, params }) => (${cfg.rateKeyExpr})` : ''} })`;

    const rawBody = `export const ${handlerName} = makeHandlerRaw${hasBody ? `<typeof ${bodyAlias}>` : '<unknown>'}(
  ${rawGuard},
  async ({ req, params, body, ctx, requestId }) => {${userCode}
    return result as Response;
  }
);`;

    const allImports = [...importLines];
    if (bodySchemaDecl) allImports.push(bodySchemaDecl);
    if (querySchemaDecl) allImports.push(querySchemaDecl);
    return [allImports.join('\n'), header, rawBody]
      .filter(Boolean)
      .join('\n\n');
  } else {
    const bodyCode = `export const ${handlerName} = makeHandler${hasBody ? `<typeof ${bodyAlias}>` : '<unknown>'}(
  ${guard},
  async ({ req, params, body, ctx, requestId }) => {${userCode}
    return result as unknown;
  }
);`;

    const allImports = [...importLines];
    if (bodySchemaDecl) allImports.push(bodySchemaDecl);
    if (querySchemaDecl) allImports.push(querySchemaDecl);
    return [allImports.join('\n'), header, bodyCode]
      .filter(Boolean)
      .join('\n\n');
  }
}
