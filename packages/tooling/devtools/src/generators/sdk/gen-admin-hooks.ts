/**
 * Admin Grid Hooks Generator
 *
 * Generates admin list params hooks and grid registries from gateway admin list configs.
 * This consolidates the previous saaskit-specific gen-admin-grid-registries.ts into devtools.
 */
import * as fs from 'node:fs';
import * as path from 'node:path';
import { log } from '../../utils/logger.js';
import { ensureDir } from '../../utils/fs.js';

// Type definitions matching @unisane/gateway
interface FieldDef {
  type: 'string' | 'enum' | 'date' | 'number';
  ops?: string[];
  enumValues?: readonly string[] | string[];
}

interface AdminListConfig {
  id: string;
  path: [string, string]; // [namespace, resource]
  hookName: string;
  defaultSort: string;
  defaultLimit: number;
  fieldsRegistry: Record<string, FieldDef>;
  mapFilters: (filters: Record<string, unknown>, search?: string) => Record<string, unknown>;
  deriveQuery?: (args: unknown) => unknown;
  facetsOp?: string[];
  facetsMap?: (res: unknown) => Record<string, Record<string, number>>;
}

export interface GenAdminHooksOptions {
  /** Output directory for generated files */
  output: string;
  /** Admin list configs from gateway */
  adminListConfigs: AdminListConfig[];
  /** Whether to skip writing files */
  dryRun?: boolean;
}

const HEADER = `/* AUTO-GENERATED by @unisane/devtools sdk:gen --admin-hooks â€” DO NOT EDIT */\n`;

const toPascal = (value: string) =>
  value
    .split(/[^A-Za-z0-9]+/g)
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join('');

const singularize = (value: string) =>
  value.endsWith('s') ? value.slice(0, -1) : value;

const registryNames = (cfg: AdminListConfig) => {
  const resource = singularize(cfg.id.replace(/^admin\./, ''));
  const pascal = toPascal(resource);
  return {
    mapFn: `mapAdmin${pascal}Filters`,
    deriveFn: `deriveAdmin${pascal}ListQuery`,
  };
};

/**
 * Generate field registry files for each admin list config
 */
function emitFields(
  outputDir: string,
  name: string,
  reg: Record<string, FieldDef>,
  dryRun: boolean
): void {
  const out: Record<string, FieldDef> = {};
  for (const [k, v] of Object.entries(reg)) {
    const enumValues = v.enumValues;
    out[k] = {
      type: v.type,
      ...(Array.isArray(v.ops) ? { ops: v.ops } : {}),
      ...(Array.isArray(enumValues) ? { enumValues } : {}),
    };
  }

  const body = `export type UiFieldDef = { type: 'string' | 'enum' | 'date' | 'number'; ops?: string[]; enumValues?: readonly string[] | string[] };\nexport const fields: Record<string, UiFieldDef> = ${JSON.stringify(out, null, 2)} as const;\n`;

  const dir = path.join(outputDir, 'registries/generated');
  const filePath = path.join(dir, `${name}.fields.gen.ts`);

  if (!dryRun) {
    fs.mkdirSync(dir, { recursive: true });
    fs.writeFileSync(filePath, HEADER + body, 'utf8');
  }

  log.info(`  - ${name}.fields.gen.ts`);
}

/**
 * Generate the base useAdminListParams hook
 */
function emitBaseListHelper(outputDir: string, dryRun: boolean): void {
  const body = `"use client";

import { useRouter, useSearchParams } from "next/navigation";
import { useEffect, useMemo, useRef, useState } from "react";

export interface AdminListParams {
  sort: string;
  cursor: string | undefined;
  search: string; // UI/input value
  searchCommitted: string; // debounced value used for queries
  filters: Record<string, unknown>;
  setSort: (next: string) => void;
  setCursor: (next?: string) => void;
  setSearch: (next: string) => void;
  setFilters: (next: Record<string, unknown>) => void;
  limit: number;
  setLimit: (next: number) => void;
  pageIndex: number;
  setPageIndex: (next: number) => void;
  updateUrl: (mutate: (url: URL) => void) => void;
  sortDescriptor: { key: string; direction: "asc" | "desc" };
}

export interface AdminListParamsOptions {
  defaults?: { sort?: string; limit?: number };
  initialFilters?: Record<string, unknown>;
}

export const useAdminListParams = ({
  defaults,
  initialFilters = {},
}: AdminListParamsOptions = {}): AdminListParams => {
  const sp = useSearchParams();
  const router = useRouter();

  const sortParamFromUrl = sp.get("sort") ?? defaults?.sort ?? "-createdAt";
  const cursorFromUrl = sp.get("cursor") ?? undefined;
  const searchParamFromUrl = sp.get("q") ?? "";
  const limitParam = Number(sp.get("limit") ?? "");
  const limitFromUrl = Number.isFinite(limitParam) && limitParam > 0 ? limitParam : undefined;
  const limit = Math.max(1, Math.min(limitFromUrl ?? defaults?.limit ?? 50, 500));
  // Read page from URL for persistence across refreshes
  const pageParam = Number(sp.get("page") ?? "");
  const pageFromUrl = Number.isFinite(pageParam) && pageParam > 0 ? pageParam : 1;

  const [cursor, setCursor] = useState<string | undefined>(cursorFromUrl);
  const [sort, setSort] = useState<string>(sortParamFromUrl);
  const [search, setSearch] = useState<string>(searchParamFromUrl); // raw input
  const [searchCommitted, setSearchCommitted] = useState<string>(searchParamFromUrl); // debounced
  const [filters, setFilters] = useState<Record<string, unknown>>(initialFilters);
  const [limitState, setLimit] = useState<number>(limit);
  const [pageIndex, setPageIndex] = useState<number>(pageFromUrl);

  // Sync state with URL when URL changes (e.g., browser back/forward, external navigation)
  useEffect(() => {
    setSort(sortParamFromUrl);
  }, [sortParamFromUrl]);

  useEffect(() => {
    setCursor(cursorFromUrl);
  }, [cursorFromUrl]);

  useEffect(() => {
    // Only sync if URL search differs from current state to avoid loops
    if (searchParamFromUrl !== search) {
      setSearch(searchParamFromUrl);
      setSearchCommitted(searchParamFromUrl);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchParamFromUrl]);

  // Sync limit state with URL/defaults
  useEffect(() => {
    setLimit(limit);
  }, [limit]);

  // Sync page state with URL (for browser back/forward navigation)
  useEffect(() => {
    if (pageFromUrl !== pageIndex) {
      setPageIndex(pageFromUrl);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [pageFromUrl]);

  const updateUrl = (mutate: (url: URL) => void) => {
    const url = new URL(window.location.href);
    mutate(url);
    router.replace(url.toString(), { scroll: false });
  };

  // Debounce search commits to avoid firing a request on every keystroke
  const debounceRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  useEffect(() => {
    if (debounceRef.current) clearTimeout(debounceRef.current);
    debounceRef.current = setTimeout(() => {
      const nextCommitted = search.length >= 2 || search.trim() === "" ? search : "";
      setSearchCommitted(nextCommitted);
      setCursor(undefined);
      setPageIndex(1);
      // update URL q param on commit
      updateUrl((url) => {
        if (nextCommitted.trim()) url.searchParams.set("q", nextCommitted.trim());
        else url.searchParams.delete("q");
        url.searchParams.delete("cursor");
        url.searchParams.delete("page"); // Reset to page 1
      });
    }, 250); // 250ms debounce for responsive search
    return () => {
      if (debounceRef.current) clearTimeout(debounceRef.current);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [search]);

  const sortDescriptor = useMemo(() => {
    const key = sort.startsWith("-") ? sort.slice(1) : sort;
    const direction: "asc" | "desc" = sort.startsWith("-") ? "desc" : "asc";
    return { key, direction };
  }, [sort]);

  return {
    sort,
    cursor,
    search,
    searchCommitted,
    filters,
    setSort,
    setCursor,
    setSearch,
    setFilters,
    limit: limitState,
    setLimit,
    pageIndex,
    setPageIndex,
    updateUrl,
    sortDescriptor,
  };
};
`;

  const dir = path.join(outputDir, 'hooks/generated');
  const filePath = path.join(dir, 'useAdminListParams.ts');

  if (!dryRun) {
    fs.mkdirSync(dir, { recursive: true });
    fs.writeFileSync(filePath, HEADER + body, 'utf8');
  }

  log.info('  - hooks/generated/useAdminListParams.ts');
}

/**
 * Generate list params hooks for each admin entity
 */
function emitListParamsHooks(
  outputDir: string,
  configs: AdminListConfig[],
  dryRun: boolean
): void {
  const imports = [
    `import { useMemo } from "react";`,
    `import { useSearchParams } from "next/navigation";`,
    `import { encodeFiltersParam, parseFiltersParam } from "@unisane/gateway/client";`,
    `import { useAdminListParams } from "./useAdminListParams";`,
  ];

  const registryImports = configs
    .map((c) => {
      const { mapFn } = registryNames(c);
      return `import { ${mapFn} } from "@/src/sdk/registries/${c.id}.grid";`;
    })
    .join('\n');

  const hookBodies = configs
    .map((c) => {
      const { mapFn } = registryNames(c);
      return `
export function ${c.hookName}(options: { defaults?: { sort?: string; limit?: number }; initialFilters?: Record<string, unknown> } = {}) {
  const sp = useSearchParams();
  const urlFilters = useMemo(() => parseFiltersParam(sp.get("filters")), [sp]);
  const initialFilters = useMemo(
    () => (Object.keys(urlFilters).length ? urlFilters : options.initialFilters ?? {}),
    [options.initialFilters, urlFilters]
  );

  const params = useAdminListParams({
    defaults: { sort: options.defaults?.sort ?? "${c.defaultSort}", limit: options.defaults?.limit ?? ${c.defaultLimit} },
    initialFilters,
  });

  const queryArgs = useMemo(() => {
    // Use searchCommitted (debounced) for API queries, not raw search input
    const filters = ${mapFn}(params.filters, params.searchCommitted);
    const query: { limit: number; sort: string; cursor?: string; filters?: Record<string, unknown> } = {
      limit: params.limit,
      sort: params.sort,
    };
    if (typeof params.cursor === "string") query.cursor = params.cursor;
    if (filters && Object.keys(filters).length > 0) query.filters = filters;
    return query;
  }, [params.cursor, params.filters, params.limit, params.searchCommitted, params.sort]);

  const onSearchChange = (val: string) => {
    params.setSearch(val);
    params.setCursor(undefined);
    params.updateUrl((url: URL) => {
      if (val.trim()) url.searchParams.set("q", val.trim());
      else url.searchParams.delete("q");
      url.searchParams.delete("cursor");
    });
  };

  const onFiltersChange = (next: Record<string, unknown>) => {
    params.setFilters(next);
    params.setCursor(undefined);
    params.setPageIndex(1);
    params.updateUrl((url: URL) => {
      const encoded = encodeFiltersParam(next);
      if (encoded) url.searchParams.set("filters", encoded);
      else url.searchParams.delete("filters");
      url.searchParams.delete("cursor");
      url.searchParams.delete("page"); // Reset to page 1
    });
  };

  const onSortChange = (key: string | null, dir: SortDirection) => {
    if (!key || !dir) return;
    const sortVal = \`\${dir === "desc" ? "-" : ""}\${key}\`;
    params.setSort(sortVal);
    params.setCursor(undefined);
    params.setPageIndex(1);
    params.updateUrl((url: URL) => {
      url.searchParams.set("sort", sortVal);
      url.searchParams.delete("cursor");
      url.searchParams.delete("page"); // Reset to page 1
    });
  };

  const buildCursorPagination = (cursors: { next?: string; prev?: string }) => ({
    ...(cursors.next ? { nextCursor: cursors.next } : {}),
    ...(cursors.prev ? { prevCursor: cursors.prev } : {}),
    limit: params.limit,
    pageIndex: params.pageIndex,
    onLimitChange: (n: number) => {
      params.setLimit(n);
      params.setCursor(undefined);
      params.setPageIndex(1);
      params.updateUrl((url: URL) => {
        url.searchParams.set("limit", String(n));
        url.searchParams.delete("cursor");
        url.searchParams.delete("page"); // Reset to page 1
      });
    },
    onNext: () => {
      if (!cursors.next) return;
      const nextPage = params.pageIndex + 1;
      params.setCursor(cursors.next);
      params.setPageIndex(nextPage);
      params.updateUrl((url: URL) => {
        url.searchParams.set("cursor", cursors.next as string);
        url.searchParams.set("page", String(nextPage));
      });
    },
    onPrev: () => {
      if (!cursors.prev) return;
      const prevPage = Math.max(1, params.pageIndex - 1);
      params.setCursor(cursors.prev);
      params.setPageIndex(prevPage);
      params.updateUrl((url: URL) => {
        url.searchParams.set("cursor", cursors.prev as string);
        // Clean URL when going back to page 1
        if (prevPage === 1) {
          url.searchParams.delete("page");
        } else {
          url.searchParams.set("page", String(prevPage));
        }
      });
    },
  });

  return {
    ...params,
    queryArgs,
    searchValue: params.search,
    onSearchChange,
    onFiltersChange,
    onSortChange,
    buildCursorPagination,
  };
}
`;
    })
    .join('\n');

  // Build the hooks registry object
  const grouped = configs.reduce<Record<string, Record<string, string>>>(
    (acc, c) => {
      const [ns, resource] = c.path;
      acc[ns] = acc[ns] ?? {};
      acc[ns]![resource] = c.hookName;
      return acc;
    },
    {}
  );

  const listObjectParts: string[] = ['export const listParamsHooks = {'];
  for (const [ns, resources] of Object.entries(grouped)) {
    const entries = Object.entries(resources)
      .map(([res, hook]) => `    ${res}: { useListParams: ${hook} },`)
      .join('\n');
    listObjectParts.push(`  ${ns}: {\n${entries}\n  },`);
  }
  listObjectParts.push('} as const;');
  const listObject = listObjectParts.join('\n');

  const content = [
    HEADER,
    imports.join('\n'),
    registryImports,
    '\n',
    `export type ListParamsHookOpts = { defaults?: { sort?: string; limit?: number }; initialFilters?: Record<string, unknown> };`,
    `type SortDirection = "asc" | "desc" | null;`,
    hookBodies,
    listObject,
  ].join('\n');

  const dir = path.join(outputDir, 'hooks/generated');
  const filePath = path.join(dir, 'admin-list-params.ts');

  if (!dryRun) {
    fs.mkdirSync(dir, { recursive: true });
    fs.writeFileSync(filePath, content, 'utf8');
  }

  log.info('  - hooks/generated/admin-list-params.ts');
}

/**
 * Generate admin grid registries with filter mappers
 */
function emitAdminRegistries(
  outputDir: string,
  configs: AdminListConfig[],
  dryRun: boolean
): void {
  for (const cfg of configs) {
    const filename = `${cfg.id}.grid.ts`;
    const { mapFn, deriveFn } = registryNames(cfg);

    const content = `${HEADER}import { adminListConfigs } from "@unisane/gateway";
import { fields as generatedFields } from "./generated/${cfg.id}.fields.gen";
import { createApi } from "@/src/sdk";

type UiFieldDef = { type: 'string' | 'enum' | 'date' | 'number'; ops?: string[]; enumValues?: readonly string[] | string[] };

const cfg = (() => {
  const found = adminListConfigs.find((c) => c.id === "${cfg.id}");
  if (!found) throw new Error("Missing admin list config for ${cfg.id}");
  return found;
})();

export const fields: Record<string, UiFieldDef> = generatedFields;
export const ${mapFn} = cfg.mapFilters;
export const ${deriveFn} = (args: {
  cursor?: string | null;
  sort?: string | null;
  q?: string | null;
  filters?: string | Record<string, unknown> | null;
  limit?: number;
  defaults?: { sort?: string; limit?: number };
}) => {
  const res = cfg.deriveQuery?.(args);
  if (!res) {
    const limit = args.limit ?? args.defaults?.limit ?? cfg.defaultLimit;
    const sort = args.sort ?? args.defaults?.sort ?? cfg.defaultSort;
    return { query: { limit, sort }, uiFilters: {}, search: "" };
  }
  return res as {
    query: { limit: number; sort: string; cursor?: string; filters?: Record<string, unknown> };
    uiFilters: Record<string, unknown>;
    search: string;
  };
};

export async function fetchFacets(): Promise<Record<string, Record<string, number>>> {
  if (!cfg.facetsOp) return {};
  const api = await createApi();
  const op = cfg.facetsOp.reduce<unknown>((acc, key: string) => {
    if (acc && typeof acc === "object" && key in acc) return (acc as Record<string, unknown>)[key];
    return undefined;
  }, api as unknown);
  const facOp = typeof op === "function" ? op : undefined;
  if (!facOp) return {};
  const res = await facOp();
  return cfg.facetsMap ? cfg.facetsMap(res) : (res as Record<string, Record<string, number>>);
}
`;

    const dir = path.join(outputDir, 'registries');
    const filePath = path.join(dir, filename);

    if (!dryRun) {
      fs.mkdirSync(dir, { recursive: true });
      fs.writeFileSync(filePath, content, 'utf8');
    }

    log.info(`  - registries/${filename}`);
  }
}

/**
 * Generate tenant grid registries (simpler pattern)
 */
function emitTenantRegistries(outputDir: string, dryRun: boolean): void {
  const webhooksContent = `${HEADER}import { WEBHOOK_DIRECTION, WEBHOOK_EVENT_STATUS } from '@/src/shared/constants/webhooks';

type UiFieldDef = { type: 'string' | 'enum' | 'date' | 'number'; ops?: string[]; enumValues?: readonly string[] | string[] };

export const fields: Record<string, UiFieldDef> = {
  direction: { type: 'enum', ops: ['eq', 'in'], enumValues: WEBHOOK_DIRECTION },
  status: { type: 'enum', ops: ['eq', 'in'], enumValues: WEBHOOK_EVENT_STATUS },
};

export function transformFilters(filters: Array<{ field: string; op: string; value?: unknown }>) {
  const out: Record<string, unknown> = {};
  for (const f of filters) {
    if (f.field === 'direction') {
      if (f.op === 'eq' && typeof f.value === 'string') out.direction = f.value;
      if (f.op === 'in' && Array.isArray(f.value) && f.value.length) out.direction = String(f.value[0]);
    }
    if (f.field === 'status') {
      if (f.op === 'eq' && typeof f.value === 'string') out.status = f.value;
      if (f.op === 'in' && Array.isArray(f.value) && f.value.length) out.status = String(f.value[0]);
    }
  }
  return Object.keys(out).length ? out : undefined;
}
`;

  const dir = path.join(outputDir, 'registries');
  const filePath = path.join(dir, 'tenant.webhooks.grid.ts');

  if (!dryRun) {
    fs.mkdirSync(dir, { recursive: true });
    fs.writeFileSync(filePath, webhooksContent, 'utf8');
  }

  log.info('  - registries/tenant.webhooks.grid.ts');
}

/**
 * Generate hooks index file that wires everything together
 */
function emitHooksIndex(outputDir: string, dryRun: boolean): void {
  const content = `${HEADER}import { hooks as generatedHooks } from "./generated";
import { keys as generatedKeys } from "./generated/keys";
import { listParamsHooks } from "./generated/admin-list-params";
import { useAdminListParams } from "./generated/useAdminListParams";
import { HooksProvider, useApiHooks } from "./Provider";

type AugmentedHooks = typeof generatedHooks & typeof listParamsHooks;

const hooks = generatedHooks as AugmentedHooks;
for (const [ns, resources] of Object.entries(listParamsHooks)) {
  const targetNs = ((hooks as unknown as Record<string, unknown>)[ns] as Record<string, unknown>) ?? {};
  for (const [res, fns] of Object.entries(resources as Record<string, unknown>)) {
    const existing = (targetNs[res] as Record<string, unknown>) ?? {};
    targetNs[res] = { ...existing, ...(fns as Record<string, unknown>) };
  }
  (hooks as unknown as Record<string, unknown>)[ns] = targetNs;
}

export {
  hooks,
  HooksProvider,
  useApiHooks,
  useAdminListParams,
};
export { generatedKeys as keys };
`;

  const dir = path.join(outputDir, 'hooks');
  const filePath = path.join(dir, 'index.ts');

  if (!dryRun) {
    fs.mkdirSync(dir, { recursive: true });
    fs.writeFileSync(filePath, content, 'utf8');
  }

  log.info('  - hooks/index.ts');
}

/**
 * Main generator function
 */
export async function genAdminHooks(options: GenAdminHooksOptions): Promise<void> {
  const { output, adminListConfigs, dryRun = false } = options;

  if (!dryRun) {
    await ensureDir(output);
  }

  log.info('Generating admin hooks and registries...');

  // 1. Generate field registries
  for (const cfg of adminListConfigs) {
    emitFields(output, cfg.id, cfg.fieldsRegistry, dryRun);
  }

  // 2. Generate base useAdminListParams hook
  emitBaseListHelper(output, dryRun);

  // 3. Generate list params hooks for each entity
  emitListParamsHooks(output, adminListConfigs, dryRun);

  // 4. Generate admin grid registries
  const adminConfigs = adminListConfigs.filter((c) => c.id.startsWith('admin.'));
  emitAdminRegistries(output, adminConfigs, dryRun);

  // 5. Generate tenant registries
  emitTenantRegistries(output, dryRun);

  // 6. Generate hooks index
  emitHooksIndex(output, dryRun);

  log.success(`Generated admin hooks${dryRun ? ' (dry run)' : ''}`);
}
