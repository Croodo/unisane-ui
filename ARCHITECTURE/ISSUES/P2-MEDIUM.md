# P2 Medium Priority Issues

> **For LLMs**: These issues improve code quality but don't block functionality. Fix during cleanup sprints.

---

## Summary

| ID | Issue | Layer | Status |
|----|-------|-------|--------|
| K-002 | Cache provider coupling | Kernel | **Fixed** |
| K-003 | Logger configuration scattered | Kernel | **Fixed** |
| K-004 | Razorpay status not using SSOT | Kernel | **Fixed** |
| G-003 | Route registration verbose | Gateway | **Fixed** |
| G-004 | Missing request validation | Gateway | **Fixed** |
| C-003 | Contract naming inconsistency | Contracts | **Documented** |
| C-004 | Missing contract versioning | Contracts | **Documented** |
| A-001 | Adapter config validation missing | Adapters | **Fixed** |
| A-002 | Inconsistent error types | Adapters | **Fixed** |
| M-004 | Service layer too thin | Modules | **Deferred** |
| M-005 | Repository pattern incomplete | Modules | **Deferred** |
| M-006 | Usage window not using SSOT | Modules | **Fixed** |
| S-001 | Starter-specific code in foundation | Starters | **Reviewed** |
| DX-001 | Missing development scripts | DevTools | **Fixed** |

---

## K-002: Cache Provider Coupling

### Location
`packages/foundation/kernel/src/cache/provider.ts`

### Problem
Cache provider has Vercel KV specific code mixed with generic interface.

### Impact
- Hard to swap cache providers
- Testing requires Vercel KV mock

### Fix

```typescript
// Separate interface from implementation
// cache/port.ts
export interface CachePort {
  get<T>(key: string): Promise<T | null>;
  set<T>(key: string, value: T, ttlMs?: number): Promise<void>;
  del(key: string): Promise<void>;
  incrBy(key: string, by: number, ttlMs?: number): Promise<number>;
}

// cache/providers/vercel-kv.ts
export class VercelKVCache implements CachePort {
  // Vercel-specific implementation
}

// cache/providers/memory.ts
export class MemoryCache implements CachePort {
  // Memory implementation for testing
}
```

---

## K-003: Logger Configuration Scattered

**Status: FIXED** - Logger is already centralized in kernel. All modules use `logger.child()` from kernel.

### Locations
- `packages/foundation/kernel/src/observability/logger.ts` - Single source of truth
- Gateway re-exports from kernel correctly

### Resolution
Logger configuration was already centralized. The kernel provides:
- `logger` - Main context-aware logger
- `createModuleLogger(module)` - Factory for module-specific loggers
- Configuration via env vars: `LOG_LEVEL`, `LOG_PRETTY`

---

## K-004: Razorpay Status Not Using SSOT

### Location
`packages/foundation/kernel/src/events/billing-events.ts` line 90

### Problem
Razorpay subscription event schema uses inline enum instead of mapping to SSOT `ZSubscriptionStatus`.

```typescript
// CURRENT (Inline - violates SSOT)
status: z.enum(['active', 'pending', 'halted', 'cancelled', 'completed', 'expired']),
```

### Impact
- Razorpay statuses don't map to internal subscription statuses
- Inconsistent status handling between Stripe and Razorpay
- Validation mismatch in event handling

### Fix

```typescript
// Option A: Map Razorpay statuses to internal SSOT
import { ZSubscriptionStatus } from '../constants';

// Create mapping
const RAZORPAY_TO_INTERNAL_STATUS: Record<string, SubscriptionStatus> = {
  'active': 'active',
  'pending': 'trialing',
  'halted': 'past_due',
  'cancelled': 'canceled',
  'completed': 'canceled',
  'expired': 'canceled',
};

// Use in schema with transform
status: z.enum(['active', 'pending', 'halted', 'cancelled', 'completed', 'expired'])
  .transform(s => RAZORPAY_TO_INTERNAL_STATUS[s]),

// Option B: Keep raw but add normalized field
rawStatus: z.enum(['active', 'pending', 'halted', 'cancelled', 'completed', 'expired']),
normalizedStatus: ZSubscriptionStatus,  // Handler must populate this
```

---

### Fix

```typescript
// Centralize in kernel
export const loggerConfig = {
  development: {
    level: 'debug',
    format: 'pretty',
  },
  production: {
    level: 'info',
    format: 'json',
  },
  test: {
    level: 'error',
    format: 'silent',
  },
} as const;

export function createLogger(module: string) {
  const env = getEnv('APP_ENV', 'development');
  const config = loggerConfig[env] ?? loggerConfig.development;
  return baseLogger.child({ module, ...config });
}
```

---

## G-003: Route Registration Verbose

**Status: FIXED** - Routes are auto-generated via `npm run routes:gen` from contracts.

### Resolution
Route files in `starters/saaskit/src/app/api/rest/` are auto-generated by `@unisane/devtools`.
The generator reads contracts and produces type-safe route handlers with:
- Zod validation included
- Permission checks from contract metadata
- Audit logging from contract metadata
- Rate limiting from contract metadata

### Current
```typescript
// Too verbose
router.post('/users', makeHandler({
  contract: UsersContract,
  operation: 'create',
  guards: [authGuard],
  handler: async (ctx) => { ... }
}));
```

### Fix

```typescript
// More declarative
registerRoutes(router, UsersContract, {
  create: { guards: [authGuard], handler: createUserHandler },
  update: { guards: [authGuard, ownerGuard], handler: updateUserHandler },
  delete: { guards: [authGuard, adminGuard], handler: deleteUserHandler },
});
```

---

## G-004: Missing Request Validation

**Status: FIXED** - Validation is included in auto-generated routes via Zod schemas.

### Resolution
The route generator includes `zod: __BodySchema` in makeHandler options.
The `makeHandler` function in `@unisane/gateway` validates request body using the schema.
All auto-generated routes have validation built-in.

### Fix

```typescript
// Add validation middleware
export const validateRequest = (contract: Contract) => {
  return async (req: Request, next: NextFunction) => {
    const schema = contract.body;
    if (schema) {
      const result = schema.safeParse(req.body);
      if (!result.success) {
        throw new ValidationError(result.error);
      }
      req.body = result.data; // Use parsed data
    }
    return next();
  };
};
```

---

## C-003: Contract Naming Inconsistency

**Status: DOCUMENTED** - Naming convention added to RULES.md. Existing schemas retained for backward compatibility.

### Problem
Inconsistent naming patterns in contracts:
- `ZUserCreate` vs `ZCreateUser`
- `ZAdminStatsQuery` vs `ZQueryAdminStats`

### Resolution
Naming convention documented in `ARCHITECTURE/RULES.md` under "Naming Convention Rules".
New schemas should follow `Z<Entity><Action>` convention. Legacy schemas retained for backward compatibility.

### Standard Convention:

```typescript
// Standard: Z<Entity><Action>
// Query schemas: Z<Entity><Action>Query
// Response schemas: Z<Entity><Action>Response

// Examples:
export const ZUserCreate = z.object({...});        // Create user
export const ZUserUpdate = z.object({...});        // Update user
export const ZUserListQuery = z.object({...});     // List users query
export const ZUserListResponse = z.object({...});  // List users response
```

---

## C-004: Missing Contract Versioning

**Status: DOCUMENTED** - Basic versioning exists via URL paths (`/api/rest/v1/`). Advanced versioning (multiple contract versions) can be added when needed.

### Problem
No explicit versioning strategy for API contracts beyond URL path.

### Impact
- Breaking changes affect all consumers
- No deprecation path

### Fix

```typescript
// Add version to contracts
export const UsersContractV1 = defineContract({
  version: 1,
  deprecated: false,
  operations: {
    create: { ... },
  },
});

export const UsersContractV2 = defineContract({
  version: 2,
  deprecated: false,
  operations: {
    create: { ... }, // Updated schema
  },
});

// Route registration handles versioning
registerVersionedRoutes(router, '/api/v1/users', UsersContractV1);
registerVersionedRoutes(router, '/api/v2/users', UsersContractV2);
```

---

## A-001: Adapter Config Validation Missing

### Problem
Most adapters don't validate their configuration at construction time.

### Example
```typescript
// Current - fails at runtime
new StripeAdapter({ apiKey: undefined }); // No error until first call
```

### Fix

```typescript
// Validate in constructor
export class StripeAdapter implements BillingPort {
  constructor(config: StripeConfig) {
    const result = ZStripeConfig.safeParse(config);
    if (!result.success) {
      throw new ConfigurationError('stripe', result.error);
    }
    this.config = result.data;
  }
}
```

---

## A-002: Inconsistent Error Types

### Problem
Adapters throw different error types for similar failures:
- `Error('Network error')`
- `new NetworkError()`
- `{ code: 'NETWORK_ERROR' }`

### Fix

```typescript
// Standardize adapter errors
export class AdapterError extends Error {
  constructor(
    public adapter: string,
    public operation: string,
    public cause: unknown,
    public retryable: boolean = false
  ) {
    super(`${adapter}.${operation} failed`);
  }
}

export class NetworkError extends AdapterError {
  constructor(adapter: string, operation: string, cause: unknown) {
    super(adapter, operation, cause, true); // Retryable
  }
}

export class ConfigurationError extends AdapterError {
  constructor(adapter: string, cause: unknown) {
    super(adapter, 'configure', cause, false); // Not retryable
  }
}
```

---

## M-004: Service Layer Too Thin

**Status: DEFERRED** - Not all services need complex business logic. Simple pass-through is acceptable for CRUD operations.

### Problem
Some modules have services that are just pass-through to repositories.

### Example
```typescript
// Too thin - no value added
export function getUser(id: string) {
  return userRepository.findById(id);
}
```

### Fix
Services should contain business logic:

```typescript
// Better - contains business logic
export async function getUser(id: string, requesterId: string) {
  const user = await userRepository.findById(id);
  if (!user) throw new NotFoundError('user', id);

  // Business logic: check access
  const canAccess = await checkUserAccess(requesterId, user);
  if (!canAccess) throw new ForbiddenError();

  // Business logic: mask sensitive data
  return maskSensitiveFields(user, requesterId);
}
```

---

## M-005: Repository Pattern Incomplete

**Status: DEFERRED** - Would require significant refactoring. Most repositories are functional. Consider for future cleanup.

### Problem
Some repositories expose raw database queries instead of domain methods.

### Example
```typescript
// Exposes implementation details
export const userRepo = {
  collection: () => col<User>('users'),
  aggregate: (pipeline: any[]) => col<User>('users').aggregate(pipeline),
};
```

### Fix

```typescript
// Domain-focused interface
export interface UserRepository {
  findById(id: string): Promise<User | null>;
  findByEmail(email: string): Promise<User | null>;
  findByTenant(tenantId: string, pagination: Pagination): Promise<User[]>;
  create(user: CreateUser): Promise<User>;
  update(id: string, updates: UpdateUser): Promise<User>;
  delete(id: string): Promise<void>;
}

// Implementation hides database details
export class MongoUserRepository implements UserRepository {
  async findByTenant(tenantId: string, pagination: Pagination) {
    return col<User>('users')
      .find({ tenantId })
      .skip(pagination.offset)
      .limit(pagination.limit)
      .toArray();
  }
}
```

---

## M-006: Usage Window Not Using SSOT

### Location
`packages/modules/usage/src/domain/schemas.ts` line 14

### Problem
Usage module defines window enum inline instead of using kernel constant.

```typescript
// CURRENT (Inline - violates SSOT)
export const ZGetWindow = z.enum(['minute', 'hour', 'day']);
```

### Impact
- Duplicate definition of time window values
- If kernel adds new windows (e.g., 'week', 'month'), usage module won't have them
- Inconsistency risk across codebase

### Fix

```typescript
// RECOMMENDED: Import from kernel SSOT
import { ZUsageWindow } from '@unisane/kernel';

// Use directly
export const ZGetWindow = ZUsageWindow;

// Or extend if module needs subset
export const ZGetWindow = ZUsageWindow;  // Uses full set: minute, hour, day
```

### SSOT Location
`packages/foundation/kernel/src/constants/usage.ts`:
```typescript
export const USAGE_WINDOWS = ['minute', 'hour', 'day'] as const;
export type UsageWindow = (typeof USAGE_WINDOWS)[number];
export const ZUsageWindow = z.enum(USAGE_WINDOWS);
```

---

## S-001: Starter-Specific Code in Foundation

**Status: REVIEWED** - Foundation contracts are actually generic (pagination, error responses, date ranges).
Starter-specific contracts are correctly in `starters/saaskit/src/contracts/`.

### Locations Reviewed
- `packages/foundation/kernel/src/contracts/` - Contains `ZDateRangeQuery` (generic)
- `packages/foundation/contracts/src/` - Contains pagination, error schemas (generic)
- `starters/saaskit/src/contracts/` - Contains starter-specific contracts (correct location)

### Conclusion
No action needed - code is appropriately organized.

### Fix
Move to appropriate starters or make truly generic:

```typescript
// Keep in foundation - truly generic
export const ZPagination = z.object({
  limit: z.number().int().positive().max(100),
  offset: z.number().int().min(0),
});

// Move to starter - domain specific
// starters/saaskit/src/contracts/
export const ZTenantSettings = z.object({
  maxUsers: z.number(),
  features: z.array(z.string()),
});
```

---

## DX-001: Missing Development Scripts

### Problem
Common development tasks require manual commands.

### Fix
Add convenience scripts to root package.json:

```json
{
  "scripts": {
    "dev": "turbo run dev",
    "dev:saaskit": "turbo run dev --filter=@unisane/saaskit",
    "test": "turbo run test",
    "test:watch": "turbo run test -- --watch",
    "lint": "turbo run lint",
    "lint:fix": "turbo run lint -- --fix",
    "typecheck": "turbo run typecheck",
    "clean": "turbo run clean && rm -rf node_modules/.cache",
    "reset": "pnpm clean && rm -rf node_modules && pnpm install",
    "gen:routes": "turbo run gen:routes",
    "db:migrate": "turbo run db:migrate",
    "db:seed": "turbo run db:seed"
  }
}
```

---

## Prioritization Notes

These issues can be tackled in any order as they don't block each other:

**Quick Wins** (< 1 hour each):
- DX-001: Add development scripts
- C-003: Establish naming convention
- A-001: Add config validation
- M-006: Usage window SSOT (simple import change)
- K-004: Razorpay status mapping

**Medium Effort** (2-4 hours each):
- G-003: Route registration cleanup
- G-004: Request validation middleware
- A-002: Standardize error types

**Larger Refactors** (day+ each):
- K-002: Cache provider abstraction
- K-003: Logger centralization
- M-004, M-005: Service/Repository patterns
- S-001: Foundation cleanup
- C-004: Contract versioning

---

> **Last Updated**: 2025-01-15
